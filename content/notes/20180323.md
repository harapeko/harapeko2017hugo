---
title: "リストレンダリング|Vue.js再学習"
date: 2018-03-23T15:53:00+09:00
eyecatch: "/images/common/eyecatch/vuejs.png"
eyecatch_alt: "vue.js"
categories: "notes"
tags: [vuejs]
draft: true
---

触れないタイミングが3ヶ月あったり忘れてしまった事に焦りを感じたので、今度は勉強したことをブロクに残していきたいと思います。
内容的には公式ドキュメントの写経のようなものになります。

今日はリストレンダリングを見ていきます。

[リストレンダリング](https://jp.vuejs.org/v2/guide/list.html)

# リストレンダリング
## `v-for`で配列の要素がある分だけ売り返し処理する

`v-for`は`item in items`形式の特別な構文を要求します。
`items`がソースデータの配列で、`item`繰り返されていく配列要素の*エイリアス*です。

```html
<ul id="example">
  <li v-for="item in items">
    {{ item.message }}
  </li>
</ul>
```

```JavaScript
var example = new Vue({
  el: '#example-1',
  data: {
    items: [
      { message: 'Foo' },
      { message: 'Bar' },
    ]
  }
})
```

結果：

<div class="sc-demo">
  <ul id="example-1">
    <li>Foo</li>
    <li>Bar</li>
  </ul>
</div>

`v-for`ブロック内では、親スコープのプロパティへの完全なアクセスを持っています。
また、現在の要素に対するインデックスを、任意な2つ目の引数としてサポートしています。

```html
<ul id="example-2">
  <li v-for="(item, index) in items">
    {{ parentMessage }} - {{ index }} - {{ item.message }}
  </li>
</ul>
```

```JavaScript
var example2 = new Vue({
  el: '#example-2',
  data: {
    parentMessage: 'Parent',
    items: [
      { message: 'Foo' },
      { message: 'Bar' },
    ]
  }
}) 
```

結果：

<div class="sc-demo">
  <ul id="example-2">
    <li>Parent - 0 - Foo</li>
    <li>Parent - 1 - Bar</li>
  </ul>
</div>

また、区切り文字として`in`の代わりに`of`を使用することができます。
これはJavaScriptのイテレータ構文に近いものです。

```html
<div v-fro="item of items"></div>
```

## オブジェクトの`v-for`

```html
<ul id="v-for-object">
  <li v-for="value in object">
    {{ value }}
  </li>
</ul>
```

```JavaScript
new Vue({
  el: '#v-for-object',
  data: {
    object: {
      firstName: 'John',
      lastName: 'Doe',
      age: 30,
    }
  }
})
```

結果：

<div class="sc-demo">
  <ul id="v-for-object">
    <li>John</li>
    <li>Doe</li>
    <li>30</li>
  </ul>
</div>

2つ目の引数としてkeyも提供できます：

```html
<div v-for="(value, key) in object">
  {{ key }}: {{ value }}
</div>
```

結果：

<div class="sc-demo">
  <ul id="v-for-object">
    <li>firstName: John</li>
    <li>lastName: Doe</li>
    <li>age: 30</li>
  </ul>
</div>

indexも提供できます：

```html
<div v-for="(value, key, index) in object">
  {{ index }}. {{ key }}: {{ value }}
</div>
```

オブジェクトを反復処理するとき、順序は`Object.keys()`の列挙順のキーに基づいており、全てのJavaScriptエンジンの実装で一貫性が保証されていません。

## `key`

Vueが`v-for`で描画された要素のリストを更新する際、標準では「その場でパッチを適用する(in-place path)戦略が用いられます。
データのアイテムの順序が変更された場合、アイテムの順序に合わせてDOM要素を移動する代わりに、各要素にその場でパッチを適用して、その特定のインデックスに何を描画するべきかを確実に反映します。

この標準のモードは効率がいいです。
しかしこれは、描画されたリストが、子コンポーネントの状態や一時的なDOMの状態に依存していないときにだけ適しています。(例：フォームのインプットの値)

これに関して、こちらのstackoverflowにデモがあって分かりやすいです。
<a href="https://ja.stackoverflow.com/questions/42250/v-bindkey-%E3%82%92%E4%BD%BF%E3%81%86%E6%99%82%E3%81%A8%E4%BD%BF%E3%82%8F%E3%81%AA%E3%81%84%E6%99%82%E3%81%AE%E9%81%95%E3%81%84?newreg=cb6ef675b029442b87fc7fa2acae189b" target="_blank">v-bind:key を使う時と使わない時の違い</a>

Vueが各ノードの識別情報を追跡できるヒントを与えるために、また、先程説明したような既存の要素の再利用と並び替えができるように、一意な`key`属性を全てのアイテムに与える必要があります。
`v-bind`を使って動的な値に束縛することができます。

```html
<div v-for="item in items" :key="item.id">
  <!-- content -->
</div>
```

`v-for`に`key`を指定しないと警告が出ますし、なるべく指定することが推奨されます。
これは繰り返されるDOMの内容が単純でない、または性能向上を標準の動作に意図的に頼っていない場合に限ります。

これはVueがノードを識別する汎用的な仕組みなので、`key`はガイドの後半でわかるように`v-for`に縛られない他の用途もあります。

## 配列の変化を検出

### 変更メソッド

Vueは画面の更新もトリガするために、監視された配列の変更メソッドを抱合(wrap)します。
抱合されたメソッドは次の通りです。

- `push()`
- `pop()`
- `shift()`
- `unshift()`
- `splice()`
- `sort()`
- `reverse()`

コンソールを開いて`items`配列の例で変更メソッドを呼び出して遊んでみてください。
例えば`example1.items.push({ message: 'Baz' })のようにしてみましょう。

### 配列の置き換え

変更メソッドは、名前が示唆するように、それらが呼ばれると元の配列を変更します。
変更しないメソッドもあります。例えば、`filter()`、`concat()`、そして`slice()`のような、元の配列を変更しませんが、*常に新しい配列を返します*。変更しないメソッドで動作するとき、新しいもので古い配列を置き換えます。

```JavaScript
example1.items = example1.items.filter(function(item) {
  return item.message.match(/Foo/)
})
```

これは、Vueが既存のDOMを捨てて、リスト全体を再描画の原因になると思うかもしれません。
幸いにもそれはそうではありません。VueはDOM要素の再利用を最大化するためにいくつかのスマートなヒューリスティックを実装しているので、重複するオブジェクトを含んでいる他の配列を配列で置き換えることは、とても効率的な作業です。

### 注意事項

JavaScriptの制限のため、Vueは配列で以下の変更を検出することはできません。

+ インデックスでアイテムを直接指定するとき。例：`vm.items[indexOfItem] = newValue`
+ 配列の長さを変更するとき。例：`vm.items.length = newLength`

例：

```JavaScript
var vm = new Vue({
  data: {
    items: ['a', 'b', 'c']
  }
})
vm.items[1] = 'x' // リアクティブでない
vm.items.length = 2 // リアクティブでない
```

上記の注意事項1に対処するため、以下のどちらも`vm.items[indexOfItem] = newValue`と同じ動作になりますが、リアクティブなシステム内で状態の更新をトリガします。

```JavaScript
// Vue.set
Vue.set(vm.items, indexOfItem, newValue)
```

```JavaScript
// Array.protoype.splice
vm.items.splice(indexOfItem, 1, newValue)
```

`vm.$set`インスタンスメソッドを使用することもできます。これはグローバル`Vue.set`のエイリアスです。

```JavaScript
vm.$set(vm.items, indexOfItem, newValue)
```

上記の注意事項2に対処するためにも`splice`を使います。

```JavaScript
vm.items.splice(newLength)
```

#### 参考
<a href="https://jp.vuejs.org/v2/api/#Vue-set" target="_blank">Vue.set( target, key, value )</a>
<a href="https://jp.vuejs.org/v2/api/#vm-set" target="_blank">vm.$set( target, key, value )</a>
<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank">Array.prototype.splice()</a>

## オブジェクトの変更検出の注意

再度になりますが、現代のJavaScriptの制約のため、*Vueはプロパティの追加や削除を検出することはできません*。
例：

```JavaScript
var vm = new Vue({
  data: {
    a: 1
  }
})
// 'vm.a' はリアクティブです
// (vmインスタンス作成時にプロパティが登録されていたので)

vm.b = 2
// 'vm.b'はリアクティブではありません
// (新たにプロパティへの追加が行われたので)
```

Vueはすでに作成されたインスタンスに新しいルートレベルのりアクティブプロパティを動的に追加することはできません。
しかし、`Vue.set(object, key, value)`メソッドを使ってネストされたオブジェクトにリアクティブなプロパティを追加することは可能です。
例：

```JavaScript
var vm = new Vue({
  data: {
    userProfile: {
      name: 'Anika'
    }
  }
})
```

ネストされた`userProfile`オブジェクトに新しい`age`プロパティを追加することができます

```JavaScript
Vue.set(vm.userProfile, 'age', 27)
```

`vm.$set`インスタンスメソッドを使用することもできます。
これはグローバル`Vue.set`のエイリアスです。

```JavaScript
vm.$set(vm.userProfile, 'age', 27)
```

例えば`Object.assign()`や`_.extend()`を使って既存のオブジェクトにいくつかの新しいプロパティを割り当てたいときがあります。
このような場合は、両方のオブジェクトのプロパティを使用して新しいオブジェクトを作成する必要があります。
なので以下のやり方ではなくて

```JavaScript
Object.assign(vm.userProfile, {
  age: 27,
  favroiteColor: 'Vue Green'
})
```

新しいリアクティブプロパティをこのように追加します。

```JavaScript
vm.userProfile = Object.assign({}, vm.userProfile, {
  age: 27,
  favoriteColor: 'Vue Green'
})
```

## フィルタ/ソートされた結果の表示

ときどき、元のデータを実際に変更またはリセットすることなしに、フィルタリングやソートされたバージョンの配列を表示したいことがあります。
このケースでは、フィルタリングやソートされた配列を返す算出プロパティを作ることができます。

例えば

```html
<li v-for="n in evenNumberse">{{ n }}</li>
```

```JavaScript
data: {
  numbers: [1, 2, 3, 4, 5]
},
computed: {
  evenNumbers: function() {
    return this.numbers.filter(function(number) {
      return number % 2 === 0
    })
  }
}
```

算出プロパティが使えない状況ではメソッドを使うこともできます。(例:入れ子になった`v-for`のループの中)

```html
<li v-for="n in even(numbers)">{{ n }}</li>
```

```JavaScript
data: {
  numbers: [1, 2, 3, 4, 5]
},
methods: {
  even: function(numbers) {
    return numbers.filter(function(number) {
      return number % 2 === 0
    })
  }
}
```

## 範囲付き`v-for`

`v-for` は整数値を取ることもできます。
このケースでは、指定された数だけテンプレートが繰り返されます。

```html
<div>
  <span v-for="n in 10">{{ n }} </span>
</div>
```

<div class="sc-demo">
  <span>1 </span>
  <span>2 </span>
  <span>3 </span>
  <span>4 </span>
  <span>5 </span>
  <span>6 </span>
  <span>7 </span>
  <span>8 </span>
  <span>9 </span>
  <span>10 </span>
</div>

## `<template>`での`v-for`

## `v-for`と`v-if`

## コンポーネントと`v-for`